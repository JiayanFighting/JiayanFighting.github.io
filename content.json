{"meta":{"title":"Jiayan's Blog","subtitle":"","description":"欢迎来到家晏的博客","author":"Jiayan Huang","url":"https://jiayanfighting.github.io","root":"/"},"pages":[{"title":"MySQL架构","date":"2020-06-19T13:04:59.000Z","updated":"2020-06-19T13:04:59.708Z","comments":true,"path":"MySQL架构/index.html","permalink":"https://jiayanfighting.github.io/MySQL%E6%9E%B6%E6%9E%84/index.html","excerpt":"","text":""},{"title":"about","date":"2020-02-02T12:02:20.000Z","updated":"2020-06-19T12:41:04.631Z","comments":true,"path":"about/index.html","permalink":"https://jiayanfighting.github.io/about/index.html","excerpt":"","text":"个人简介 基本信息 姓名：黄家晏 年龄：23岁 Email： JiayanFighting@qq.com 教育背景 2019.9-2021.6 哈尔滨工业大学 计算机科学与技术 硕士 实验室：海量数据计算研究中心 研究方向：边缘计算，移动边缘计算系统中的任务调度算法和边缘云的定价博弈 2015.9-2019.6 哈尔滨工业大学 软件工程 学士 专业排名：4/101 CET-6 主修课程：数据结构，算法分析与设计，操作系统，计算机网络，数据库系统，Java，Java EE 等。 专业技能 熟悉Java语法，具有Java编程相关经验 对JVM，垃圾回收机制，内存模型等有一定了解 对数据结构、算法有一定了解 了解常用Java开源框架， SpringMVC、Spring Boot、MyBatis等 熟悉MySQL，Redis等主流数据库，熟悉事务、索引等数据库相关技术 熟悉HTTP，TCP，IP等网络协议 了解PHP语言，有一定的PHP编程相关经验 了解HTML、CSS、AJAX等前端技术和React技术框架 掌握Git，SVN，Charles，Matlab等常用工具 实习经历 2018.8-2019.5 北京小唱科技有限公司 后端开发实习生 责任描述： 唱吧App的功能开发，包括版本功能开发，活动开发等。 礼物系统重构。从后端系统中解耦出礼物相关功能，兼容原接口，重新构建礼物系统，并引入定制化礼物箱功 能，实现礼物后台接口。 活动数据的统计，线上bug的修复等。 涉及技术：PHP，Nginx，数据库相关技术，包括MySQL，Redis，Memcached等。 2017.7-2017.8 东软 开发实习生 功能描述：管理公司的人员出勤情况；员工职位变化，部门更改等信息管理；员工请假，逐级审批，假期计算等 功能。 责任描述： 数据库的设计；系统功能模块的划分；部门信息管理和请假管理的代码的书写；组员工作的分配；代 码的整合。 涉及技术：Spring，SpringMVC，Mybatis，MySQL等。 项目经验 2018.11-2019.3 评论过滤系统 功能描述：用户进行评论操作时，进行评论的分类，筛选中言语不当的评论，阻止该评论的发表。 系统设计：分为四个模块，首先对文本和用户属性数据的提取，然后将提取的数据进行预处理，再用朴素贝叶斯 算法训练分类模型，最后利用互信息和左右信息熵在负面评论中挖掘新的骂人词汇，辅助分类模型进行强分类， 优化分类效果。 涉及技术：机器学习，MySQL，Redis，Python等。 2017.12-2018.3 渠道交易平台 功能描述：渠道商，销售人员，渠道商管理人员，商户，系统管理人员的信息管理；订单管理，提成计算等；权 限管理。 责任描述：不同级别的渠道商服务商和代理商的信息处理；销售人员的信息管理；各级渠道商和销售人员的交易 统计，提成计算；文件的导入与导出。 涉及技术：SpringBoot，Mybatis，MySQL，Thymeleaf，Shiro等。 2017.11-2017.12 编译器 功能描述： • 词法分析。根据输入的代码，自动识别出单词关键字数字等，列出token 序列。能识别各种单词拼写错误。 • 语法分析。能识别声明语句，赋值语句，分支语句，循环语句等，构造语法分析树，并具备语法错误处理能力。 • 语义分析。识别常用语句类型，并生成中间代码，列出符号表，三地址指令和四元式序列等，并具备语义错误处 理能力，能准确给出错误所在位置，并采用可行的错误恢复策略。 研究方向 Paper：《Approximated Assignment Algorithms for Unordered and Ordered Tasks in Data Shared MEC Systems 》 Journal: Transactions on Mobile Computing Status：Under Review 本文详细研究了数据共享移动边缘计算系统中的任务分配算法。针对MEC系统中常见的有序任务，给出了一种启 发式算法。从理论上分析了该问题的难易程度、算法的正确性、复杂度。最后，进行了大量的实验研究。理论分 析和实验结果均表明，所提出的算法在时延、满足率和能量消耗方面都具有较高的性能。 荣誉奖项 一等优秀推免奖学金，长园奖学金 多次获得一等人民奖学金，励志奖学金 蓝桥杯Java软件开发大学A组二等奖 基于Unity3D冒险类游戏开发二等奖 个人评价 乐观开朗，适应能力强，能接受加班和出差 热爱写代码，有良好的编程习惯 具有良好的沟通能力，能快速融入团队 有责任心，学习能力强 谢谢观看！ 如果有合适的工作岗位，欢迎联系！"},{"title":"categories","date":"2020-05-06T14:46:57.000Z","updated":"2020-06-19T14:02:47.945Z","comments":true,"path":"categories/index.html","permalink":"https://jiayanfighting.github.io/categories/index.html","excerpt":"","text":"分类是什么？"},{"title":"tags","date":"2020-05-06T14:47:10.000Z","updated":"2020-06-19T14:01:56.243Z","comments":true,"path":"tags/index.html","permalink":"https://jiayanfighting.github.io/tags/index.html","excerpt":"","text":"Java MySQL 计算机网络 算法 操作系统 Spring record"}],"posts":[{"title":"Java 集合","slug":"Java-集合","date":"2020-08-17T08:58:44.000Z","updated":"2020-08-17T09:44:06.655Z","comments":true,"path":"2020/08/17/Java-集合/","link":"","permalink":"https://jiayanfighting.github.io/2020/08/17/Java-%E9%9B%86%E5%90%88/","excerpt":"主要总结一下我们经常用到的几种集合类。 ArrayList,LinkedList,HashMap,HashSet,TreeMap,TreeSet,ConcurrentHashMap… 首先献上一张图","text":"主要总结一下我们经常用到的几种集合类。 ArrayList,LinkedList,HashMap,HashSet,TreeMap,TreeSet,ConcurrentHashMap… 首先献上一张图 概述 1. 合集Collection Collection接口是处理对象合集的根接口，此接口中包含了大量的集合接口以及这些接口的实现类和操作他们的算法，具体而言，主要提供了List(列表)、Queue(队列)、Set(集合)、Stack(栈)和Map(映射表，用于存放键值对等数据结构)，其中List(列表)、Queue(队列)、Set(集合)、Stack(栈)都继承自Collection接口。 2. 迭代器Iterator Iterator接口用于在不需要暴露数据是如何保存在数据结构的细节的情况下，来遍历一个数据结构。他会返回一个实现了Interator接口的是对象。如果对正在被迭代的集合进行结构上的改变，那么迭代器将不再合法，会有异常抛出。 3. 线性表List 定义了一个用于顺序存储元素,允许重复的有序合集，它有三个具体的实现类： 数组线性表类ArrayList 链表类LinkedList 数组类Vector 3.1. 关于ListIterator接口 此接口扩展了List的Iterator接口的功能。方法previous和hasPrevious使得对表从后向前遍历得以完成。 3.2. 数组线性表类ArrayList ArrayList用数组存储元素，这个数组是动态创建的，即可以动态的改变数组的长度，默认扩充为原来的1.5倍 它会在内存中开辟一块连续的空间来存储，由于数据存储是连续的，所以支持用序号访问元素。 没有一个方法是同步的，所以他是线程不安全的。 优点：对数据的索引速度比较快； 缺点：对于数据的增减删除速度比较慢 3.3. Vector Vector与ArrayList一样，最大的区别就是Vector中的绝大部分方法都是直接或者间接同步的，他是线程安全的。 Vector在扩展长度时默认扩展为原来的2倍，每次扩充的空间的大小是可以设置的。 3.4. 链表类LinkedList 链表中的每个元素都包含一个称为结点的结构。每个结点与它的相邻结点相连接。每个结点都包含元素和一个名为next的数据域，next指向下一个元素，如果结点是线性表中的最后一个，那么它的指针数据域next的值为null。 单链表：包含一个指向线性表第一个结点的指针 循环单链表：链表中最后一个结点的指针指向第一个链表，其余的结点与单链表类似。 双向链表：包含两个指针的结点，一个指针指向下一个结点，另一个指针指向上一个结点，分别称为前指针和后指针。 优点:对于增加删除的速度比较块，缺点：对于随机访问的速度比较快 它是线程不安全的。 4. 栈Stack Java API中栈继承于Vector类，也可以使用ArrayList和LinkedList来实现栈。 栈是限制和插入只能在一个位置进行的表，这个位置为表的末端，叫做栈的顶(Top).栈也叫做 后进先出表。栈顶的元素是唯一可见的元素。 栈的操作一般有进栈(push)和出栈(pop) push( num) //入栈 pop() //栈顶元素出栈 empty() //判定栈是否为空 peek() //获取栈顶元素 search(num) //判端元素num是否在栈中，如果在返回1，不在返回-1。 5. 队列Queue 队列也是表，使用队列时插入在一端进行，而删除在另一端进行。可以使用数组实现也可以使用链表实现。 6. 集合（set） 集合set是一个存储和处理无重复元素的高效数据结构,它有三个具体类: 散列类HashSet 链式散列集LinkedHashSet,此类继承与hashSet 树形集TreeSet 6.1. 关于接口SortedSet 此接口继承于接口Set，保证其中的各项处于有序的状态。他的实现类是TreeSet 7. 映射 7.1. 散列(哈希) 哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把散列码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 映射又分为散列映射和树映射： 散列映射就是上面所介绍的根据散列码值映射唯一的value 树映射指的是用键的整体顺序对元素进行排序，并将其组织成搜索树，最常用的实现类TreeMap 7.2. 映射表（Map） Map是一个接口，代表由关键字以及他们的值组成的一些项的集合。关键字必须是唯一的，但是若干个关键字可以映射到相同的值。因此值不必唯一。 SorttedMap继承于Map接口，映射中的关键字保持逻辑上的 有序状态，实现类是TreeMap Map接口没有实现Iterator迭代器，因此遍历Map接口一般使用foreach方法，并提供一个接受键和值得lanbda表达式。 Map中的元素是无序的，它的实现类LinkedHashMap在里面维护了一个链表，用来记住插入元素项的顺序。 ArrayList &amp; LinkedList 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，不保证线程安全； 底层数据结构： Arraylist 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环） 插入和删除是否受元素位置的影响： ① ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 ② LinkedList 采用链表存储，所以对于add()方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O（1），如果是要在指定位置i插入和删除元素的话（(add(int index, E element)） 时间复杂度近似为o(n))因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。 一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量，不过，因为ArrayList的数组变量是用transient关键字修饰的，如果集合本身需要做序列化操作的话，ArrayList这部分多余的空间不会被序列化。 ArrayList实现原理是数组，优点在于遍历查找速度很快，但是对于插入和删除效率不高。LinkedList的实现就是链表，遍历和查找速度不高，但是插入和删除的效率很高。 HashMap 数据结构： jdk1.8之前：数据+链表 jdk1.8之后：数组+链表+红黑树（当链表长度大于阈值（默认为8）(为什么默认是8 ？)时，将链表转化为红黑树） 原因：红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。加快检索速率，减少搜索时间。 为什么会选择8作为链表转红黑树的阈值？ 桶中个数小于8的情况，此时链表的查询性能和红黑树相差不多，因为转化为树还需要时间和空间，所以此时没有转化成树的必要。 根据泊松分布，在负载因子默认为0.75的时候，单个hash槽内元素个数为8的概率小于百万分之一，所以将7作为一个分水岭，等于7的时候不转换，大于等于8的时候才进行转换，小于等于6的时候就化为链表。 初始容量 16：key 的hashcode &amp; (n - 1) , 保证均匀分布 put()： 1.8之前： 判断null； 如key和value都相同，替换原来的值； 如坑位有’人’or有hash冲突，addEntry(),然后createEntry（直接插入头部，size++）或resize 1.8之后: 0.计算hash值：(key==null)?0:(h=key.hashCode())^(h&gt;&gt;&gt;16)，前16位和后16位异或 判断数组是否为空，扩容（最开始） 根据数组长度和hash值计算 “位置”tab[i]：i=(n-1)&amp;hash 插入操作。 ​ 如果该位置tab[i]为空（之前没有node）,创建一个Node并存入。 ​ 如果tab[i]不为空 ​ 只有一个Node, 获取hash值和key 比较，如key相等，获取引用e，后面用来替换 ​ 是红黑树：((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); ​ 是链表： ​ 已经存在key,value相等的，获取引用，后面用来替换值 ​ 不存在，插入到尾部，如果大于TREEIFY_THRESHOLD 转换为红黑树 ​ 如果e不为空，则代表存在相同的key,进行value更新，返回 判断是否超过阈值，超过则进行扩容 区别：不对null做判断，多了树的操作，新增Node改为插在尾部。 HashMap扩容：resize() – 为什么要扩容 为什么要有负载因子 resize的条件: HashMap.Size &gt; Capacity * LoadFactor 扩容步骤：（Java8把初始化数组和扩容全写在resize方法里了） 判断旧容量，确定新容量 容量扩充为2倍，阈值*2，生成一个2倍大小的Node数组： rehash (因为index发生了变化，所以不能直接复制，得重新计算hash值) ​ newTab[e.hash&amp;(newCap-1)]=e; resizeJDK1.7 vs 1.8区别： 1.7 前后链表顺序会倒置（因为头插） 1.8 保持原来的顺序 （因为尾插） HashMap线程不安全：rehash 1.8 之前：环链表问题（头插）, 具体过程参考 https://juejin.im/post/5a224e1551882535c56cb940 1.8 之后：尾插，虽然没有循环的问题，但是put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。 Java7 &amp; Java8 HashMap对比： 数组+链表改成了数组+链表+红黑树，引入红黑树的Java8大程度得优化了HashMap的性能 发生hash冲突时，Java7会在链表头部插入，Java8会在链表尾部插入 扩容后转移数据，Java7转移前后链表顺序会倒置，Java8还是保持原来的顺序 扩容时1.7需要对元数组重新hash重新定位，1.8采用简单的判断逻辑：位置不变或索引加旧容量大小 在插入时，1.7先判断扩容后插入，1.8先插入后扩容 hash函数的实现：先拿到key的hashcode,然后高16位和低16位做异或操作。原因：尽可能减少hash碰撞，位运算高效 解决冲突的三种方法：拉链法，定址法，再散列法 拉链法：将相同hash值的对象组成一个链表放在hash值对应的槽位 定址法：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。 沿此序列逐个单元地查找，直到找到给定的关键字,或者碰到一个开放的地址(即该地址单元为空)为止(若要插入,在探查到开放的地址，则可将待插入的新结点存人该地址单元)。 再散列法：重新计算hash值 HashMap的线程安全的实现： HashTable ConcurrentHashMap SynchronizedMap ConcurrentHashMap 数据结构： jdk1.8之前：数据+链表 jdk1.8之后：数组+链表+红黑树（当链表长度大于阈值（默认为8）时，将链表转化为红黑树），初始容量，装载因子都和hashmap一样 线程安全： JDK1.7：分段锁 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，在写操作put，remove，扩容的时候，会对Segment加锁，所以仅仅影响这个Segment，不同的Segment还是可以并发的，所以解决了线程的安全问题，同时又采用了分段锁也提升了并发的效率。 JDK1.8：synchronized 和 CAS 首先通过 hash 找到对应链表过后， 查看是否是第一个object， 如果是， 直接用CAS原则插入，无需加锁，然后如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。 为什么放弃分段锁： 原因： 加入多个分段锁浪费内存空间。 生产环境中，map在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。 为了提高 GC 的效率 ConcurrentHashMap– put()： 1.判断table是否为空， 2.找到对应的hash槽，如果是空的话，CAS插入 3.其他情况直接对hash槽的Node用synchronized加锁 12f = tabAt(tab,i=(n-1)&amp;hash)synchronized(f)&#123;……&#125; LinkedHashMap &amp; TreeMap &amp; HashMap LinkedHashMap： LinkedHashMap是继承于HashMap，是基于HashMap和双向链表来实现的。 LinkedHashMap是有序的，且默认为插入顺序。在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的。在遍历的时候会比HashMap慢。有HashMap的全部特性。 TreeMap: TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。 基于红黑树（自平衡二叉查找树）实现 TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iteraor遍历TreeMap时，得到的记录是排过序的。TreeMap的键和值都不能为空。 ​ HashSet &amp; TreeSet HashSet: 检查重复： 当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。 HashSet和HashMap： HashSet的value存的是一个static finial PRESENT = newObject()。而HashSet的remove是使用HashMap实现,则是map.remove而map的移除会返回value,如果底层value都是存null,显然将无法分辨是否移除成功。 TreeSet: TreeSet是一个包含有序的且没有重复元素的集合，通过TreeMap实现。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"Leetcode-链表","slug":"Leetcode-链表","date":"2020-06-23T13:51:15.000Z","updated":"2020-06-23T14:27:15.626Z","comments":true,"path":"2020/06/23/Leetcode-链表/","link":"","permalink":"https://jiayanfighting.github.io/2020/06/23/Leetcode-%E9%93%BE%E8%A1%A8/","excerpt":"链表是一个很重要的数据结构。","text":"链表是一个很重要的数据结构。 2. 两数相加 题目描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路 数字是逆序的就还好，遍历对应位置相加就可以了，需要用一个数记录是否有进位。还需要注意的点就是两个链表不一样长的情况别忘了把长的链表剩下的部分加上，然后再就是最后要判断是否进位为0。 代码 1234567891011121314151617181920212223242526public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int carry = 0; ListNode res = new ListNode(0); ListNode node = res; while (l1 !=null || l2 != null) &#123; if (l1 == null) &#123; node.next = new ListNode((l2.val + carry) % 10); carry = (l2.val + carry) / 10; l2 = l2.next; &#125;else if (l2 == null) &#123; node.next = new ListNode((l1.val + carry) % 10); carry = (l1.val + carry) / 10; l1 = l1.next; &#125;else &#123; node.next = new ListNode((l1.val + l2.val + carry) % 10); carry = (l1.val + l2.val + carry) / 10; l1 = l1.next; l2 = l2.next; &#125; node = node.next; &#125; if (carry &gt; 0) &#123; node.next = new ListNode(carry); &#125; return res.next;&#125; 复杂度分析 n,m为两个链表的长度 时间复杂度：O( max(n,m) ) 空间复杂度：O( max(n,m) )","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jiayanfighting.github.io/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://jiayanfighting.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode-巧用数据结构","slug":"Leetcode-巧用数据结构","date":"2020-06-23T13:20:04.000Z","updated":"2020-06-23T15:35:42.260Z","comments":true,"path":"2020/06/23/Leetcode-巧用数据结构/","link":"","permalink":"https://jiayanfighting.github.io/2020/06/23/Leetcode-%E5%B7%A7%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"最近开始刷题啦！写个总结记录一下。 开始吧！","text":"最近开始刷题啦！写个总结记录一下。 开始吧！ 1. 两数之和 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路 最开始我就直接用双指针的方法（被这个例子误导了），后来仔细想想是不对的，因为是无序的，排序的话会被打乱顺序。so，方法如下： Hashmap记录每个被需要的数字和下标。 遍历一遍数组，遍历的时候判断是否当前数字是否被需要？是，恭喜你找到了你的另一半。否，那就标记一下继续旅程吧。 代码 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; int[] res = new int[2]; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0;i&lt;nums.length;i++) &#123; if (map.containsKey(nums[i])) &#123; res[0] = map.get(nums[i]); res[1] = i; return res; &#125;else &#123; map.put(target-nums[i],i); &#125; &#125; return res;&#125; 复杂度分析 时间复杂度O(n). 只用遍历一遍 空间复杂度O(n). hashmap最多存n个元素 3. 无重复字符的最长子串 题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 解题思路 方法一：双指针 方法二：用hashmap存每个字母最后出现的位置，（主要就是模拟正常思路) 代码 12345678910111213public int lengthOfLongestSubstring(String s) &#123; int maxLen = 0; int last = 0; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for (int i=0;i&lt;s.length();i++) &#123; if (map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i)) &gt;= last) &#123; last = map.get(s.charAt(i)) + 1; &#125; map.put(s.charAt(i),i); maxLen = Math.max(maxLen, i - last + 1); &#125; return maxLen;&#125; 复杂度分析 时间复杂度：O(n)，n为字符串的长度，因为只遍历了一遍。 空间复杂度：O(m)，m表示不同的字符的个数，用map存数据","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://jiayanfighting.github.io/tags/Leetcode/"},{"name":"Map","slug":"Map","permalink":"https://jiayanfighting.github.io/tags/Map/"}]},{"title":"MySQL架构","slug":"MySQL架构","date":"2020-06-19T13:06:34.000Z","updated":"2020-06-19T13:11:39.791Z","comments":true,"path":"2020/06/19/MySQL架构/","link":"","permalink":"https://jiayanfighting.github.io/2020/06/19/MySQL%E6%9E%B6%E6%9E%84/","excerpt":"MySQL的架构","text":"MySQL的架构 图片引自知乎@Java领域佼佼者","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"Java类加载","slug":"Java类加载","date":"2020-06-12T10:43:11.000Z","updated":"2020-07-13T11:25:56.504Z","comments":true,"path":"2020/06/12/Java类加载/","link":"","permalink":"https://jiayanfighting.github.io/2020/06/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/","excerpt":"Java 类加载 类加载时机 类加载过程 类加载器","text":"Java 类加载 类加载时机 类加载过程 类加载器 类加载时机","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"计算机网络知识点","slug":"计算机网络知识点","date":"2020-05-31T15:06:19.000Z","updated":"2020-06-19T14:08:19.992Z","comments":true,"path":"2020/05/31/计算机网络知识点/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"先粗糙的总结一下。","text":"先粗糙的总结一下。 网络体系结构 OSI参考模型：各层的功能 TCP/IP参考模型 五层参考模型 HTTP HTTPS HTTP的基本概念 HTTP连接：非持久性连接和持久性连接 [HTTP消息格式] [HTTP请求方法] [HTTP状态码] [HTTPS工作原理] [HTTP vs HTTPS] [HTTP 各版本比较] [DNS] Cookie Session Token TCP [TCP概述/优点] 连接建立 [三次握手]：过程/为什么 [四次挥手]：过程/为什么 可靠传输（滑动窗口） [GBN （Go-Back-N）协议] [SR（Selective Repeat）协议] 拥塞控制 [加性增—乘性减: AIMD] [慢启动: SS] [快速重传机制] [流量控制] UDP [UDP 特点/性质/好处] [UDP简单的差错校验] [TCP 与 UDP 对比] 在浏览器输入 URL 回车之后发生了什么？","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jiayanfighting.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"SpringBoot项目部署到服务器","slug":"SpringBoot项目部署到服务器","date":"2020-05-31T14:40:22.000Z","updated":"2020-05-31T14:55:37.985Z","comments":true,"path":"2020/05/31/SpringBoot项目部署到服务器/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/31/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"有两种方法，jar 和war. 主要讲一下用jar 部署","text":"有两种方法，jar 和war. 主要讲一下用jar 部署 添加maven 依赖 Idea 图形化打包 项目生成在target目录下 jar包传到服务器上 然后执行 12java -jar cloudschool-0.0.1-SNAPSHOT.jar&#x2F;&#x2F; java -jar 生成的jar的名称","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot搭建web项目","slug":"SpringBoot搭建web项目","date":"2020-05-31T12:16:50.000Z","updated":"2020-05-31T14:12:34.518Z","comments":true,"path":"2020/05/31/SpringBoot搭建web项目/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/31/SpringBoot%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/","excerpt":"这篇文章主要介绍一下使用SpringBoot从零搭建web项目，demo主要演示登录的功能","text":"这篇文章主要介绍一下使用SpringBoot从零搭建web项目，demo主要演示登录的功能 在 https://start.spring.io/ 上生成初始化文件 会生成.zip文件，将文件解压 在IDEA中打开这个项目 ​ 这里有一个问题就是：Idea打开项目后 maven下载依赖会卡在 Resolving Maven dependencies ​ 解决：①把镜像地址换成阿里的，具体操作：更改maven 配置文件，在IDEA安装目录下IDEA\\plugins\\maven\\lib\\maven3\\conf\\setting.xml 中添加配置信息 ​ ② 修改参数设置：https://cloud.tencent.com/developer/article/1461546 运行 直接运行 src/main/java/com/google/cloudschool/CloudschoolApplication.java就可以 在浏览器输入localhost:8080就可以访问了. 简单的demo见 https://spring.io/quickstart 步入正题：访问登录界面 方法一：ip:端口/静态资源 把静态资源放到resources/static下,这是springboot静态资源默认访问路径。 在浏览器直接ip:端口/静态资源 就可以了，如： 方法二：用localhost:8080/login 编写login.html 放在resource/templates目录下。 新建LoginController 首先新建一个controller文件夹，在controller目录下新建LoginController.java。 代码： 123456789101112package com.google.cloudschool.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class LoginController &#123; @RequestMapping(\"/login\") public String welcomeLogin()&#123; return \"login\"; &#125;&#125; 在pom.xml文件中加入依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 访问localhost:8080/login 进行登录操作：后端方面 因为要用到MyBatis，所以我们首先配置MyBatis 配置MyBatis依赖 修改pom.xml文件，加入： 123456789&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; resource 目录下新建application.yml文件 进行数据源设置，写入： 123456789spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://139.196.9.111:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username: root password: 12345678mybatis: type-aliases-package: com.example.demo.dao mapper-locations: classpath:mapper/*Mapper.xml MyBatis 配置完成。 新建controller，service，dao，domain文件夹 如图： 编写login.html，Jquery Ajax发送post请求 编写controller，service, serviceImpl，mapper 文件结构 LoginController.java处理post请求方法 123456789101112131415@PostMapping(\"/login\")@ResponseBodyString ajaxLogin(String username, String password) &#123; System.out.println(\"username=\"+username+\" password=\"+password); int code = userService.login(username,password); System.out.println(\"code = \"+code); JSONObject result = new JSONObject() ; result.put(\"code\",code); if (code &gt;= 1) &#123; result.put(\"msg\",\"登录成功！\"); &#125;else &#123; result.put(\"msg\",\"用户或密码错误！\"); &#125; return result.toJSONString();&#125; UserService.java 12345package com.google.cloudschool.service;public interface UserService &#123; int login(String username, String password);&#125; UserServiceImpl.java 123456789101112131415161718package com.google.cloudschool.service.Impl;import com.google.cloudschool.dao.UserMapper;import com.google.cloudschool.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserMapper userMapper; @Override public int login(String username, String password) &#123; return userMapper.login(username,password); &#125;&#125; UserMapper.java 12345678910package com.google.cloudschool.dao;import org.apache.ibatis.annotations.*;@Mapperpublic interface UserMapper &#123; @Select(\"select count(*) from user where username = #&#123;param1&#125; and password = #&#123;param2&#125; \") int login(String username, String password);&#125; login.html 发送post登录请求就可以去数据库查询到是否有该用户啦 登录成功就跳转新界面啦！ 测试接口调用 用chrome浏览器的Talend API Tester扩展程序模拟发送请求（只调用接口的话可以注释掉thymeleaf的）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"},{"name":"web","slug":"web","permalink":"https://jiayanfighting.github.io/tags/web/"}]},{"title":"索引","slug":"索引","date":"2020-05-25T09:57:59.000Z","updated":"2020-05-25T10:00:39.487Z","comments":true,"path":"2020/05/25/索引/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/25/%E7%B4%A2%E5%BC%95/","excerpt":"MySQL中索引的优点和缺点和使用原则","text":"MySQL中索引的优点和缺点和使用原则 优点： ​ 1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引 ​ 2、大大加快数据的查询速度 缺点： 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加 2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。 使用原则： 1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引 2、数据量小的表最好不要使用索引。因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。 3、在一同值少的列上(字段上)不要建立索引，相反的，在一个字段上不同值较多可以建立索引。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://jiayanfighting.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL 优化","slug":"SQL-优化","date":"2020-05-24T15:48:18.000Z","updated":"2020-08-11T14:34:31.727Z","comments":true,"path":"2020/05/24/SQL-优化/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/24/SQL-%E4%BC%98%E5%8C%96/","excerpt":"一个好的sql语句能很好的提高sql速度 建立索引：首先考虑在 where group by及 order by 涉及的列 一定不要使用 select * 进行查询，因为会返回过多无用的字段会降低查询效率。应该使用具体的字段代替*，只返回使用到的字段。","text":"一个好的sql语句能很好的提高sql速度 建立索引：首先考虑在 where group by及 order by 涉及的列 一定不要使用 select * 进行查询，因为会返回过多无用的字段会降低查询效率。应该使用具体的字段代替*，只返回使用到的字段。 尽量不要在 where 子句中对字段进行 表达式/函数操作 ，这样也会造成全表扫描。如： 12select id FROM t_order where num/2=100select * from t_order2 where SUBSTR(customer,1,5) = 'zhang'; ​ 应改为: 12select id FROM t_order where num=100*2SELECT * FROM t_order2 WHERE customer LIKE 'zhang%'; 不要在where条件中使用左边是%的like模糊查询 ，如： 1SELECT * FROM t_order WHERE customer LIKE '%zhang' ​ 这样会导致数据库引擎放弃索引进行全表扫描。 where条件里尽量不要进行null 值的判断**，null的判断也会造成全表扫描。如： 1select * from t_order where score is NULL ​ 优化： ​ 给字段添加默认值，对默认值进行判断。如： 1select * from t_order where score = 0 应尽量避免在 where 子句中使用!=或&lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 尽量不要使用where 1=1 的条件 ​ 有时候，在开发过程中，为了方便拼装查询条件，我们会加上该条件，这样，会造成进行全表扫描。如下： 1SELECT * FROM t_order WHERE 1=1 ​ 优化： ​ 如果用代码拼装sql，则由代码进行判断，没where加where，有where加and ​ 如果用mybatis，请用mybatis的where语法。 尽量不要使用in 和not in ，会造成全表扫描。如下： 12SELECT * FROM t_order WHERE id IN (2,3)SELECT * FROM t_order1 WHERE customer IN (SELECT customer FROM t_order2) ​ 优化： ​ 对于连续的数值，能用 between 就不要用 in ，如下：SELECT * FROM t_order WHERE id BETWEEN 2 AND 3 ​ 对于子查询，可以用exists代替。如下： 1SELECT * FROM t_order1 WHERE EXISTS (SELECT * FROM t_order2 WHERE t1.customer = t2.customer) 尽量不要使用or ，会造成全表扫描。如下： 1SELECT * FROM t_order WHERE id = 1 OR id = 3 ​ 优化：可以用union代替or。如下： 123SELECT * FROM t_order WHERE id = 1UNIONSELECT * FROM t_order WHERE id = 3 很多时候用 exists 代替 in 是一个好的选择： 1select num from a where num in(select num from b) ​ 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 程序要尽量避免大事务操作，提高系统并发能力。 一个表的索引数最好不要超过6个，如果索引太多的话，就需要考虑一下那些不常使用到的列上建的索引是否有必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率， 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： ​ select col1,col2 into #t from t where 1=0 ​ 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： ​ create table #t(…) 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间。其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"Leetcode","slug":"Leetcode","date":"2020-05-17T15:59:29.000Z","updated":"2020-06-19T13:59:08.128Z","comments":true,"path":"2020/05/17/Leetcode/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/17/Leetcode/","excerpt":"说来惭愧，Leetcode只刷了一两百道题，跟有的大神比还相差太远了。但是数量不是关键，质量才是关键，所以我决定，好好的记录一下这个过程，多多总结，举一反三，题都是si的，方法才是活的。 这篇文应该会不断更新（毕竟我又不是只找一次工作），因为每次刷题应该都会悟出新的东西。 我把算法题主要分为如下几类：","text":"说来惭愧，Leetcode只刷了一两百道题，跟有的大神比还相差太远了。但是数量不是关键，质量才是关键，所以我决定，好好的记录一下这个过程，多多总结，举一反三，题都是si的，方法才是活的。 这篇文应该会不断更新（毕竟我又不是只找一次工作），因为每次刷题应该都会悟出新的东西。 我把算法题主要分为如下几类： 二分 回溯/递归 动态规划 双指针 &amp; 滑动窗口 三指针 链表 二叉树 栈 位运算 哈希 其他 二分查找 Title Des Tag Thought Complexity Code 33. 搜索旋转排序数组 搜索一个给定的目标值，数组中是否存在这个目标值， 假设数组中不存在重复元素。 二分查找 确定升序的区间 O(logN) 34. 在排序数组中查找元素的第一个和最后一个位置 升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置 二分查找 找两次，找左右边界 35. 搜索插入位置 69. x 的平方根 计算并返回 x 的平方根 二分查找 对于很大的数，乘法变除法 74. 搜索二维矩阵 二分 or 从右上角开始 81. 搜索旋转排序数组 II 搜索一个给定的目标值，数组中是否存在这个目标值， 假设数组中存在重复元素。 二分查找 O(logN) 153. 寻找旋转排序数组中的最小值 找出其中最小的元素。 假设数组中不存在重复元素。 二分 O(logN) 154. 寻找旋转排序数组中的最小值 II 找出其中最小的元素 数组中存在重复元素 二分 O(logN) 162. 寻找峰值 峰值元素是指其值大于左右相邻值的元素 二分&amp;递归 O(logN) while(l&lt;r){ int mid=(l+r)/2; if(nums[mid]&gt;nums[mid+1]) r=mid; else l=mid+1; }","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://jiayanfighting.github.io/tags/leetcode/"}]},{"title":"Transaction","slug":"Transaction","date":"2020-05-15T16:44:59.000Z","updated":"2020-05-17T15:34:30.999Z","comments":true,"path":"2020/05/16/Transaction/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/16/Transaction/","excerpt":"事务 事务的概念 事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位 事务的特性：ACID 1) 原子性（atomicity）：对于其数据修改，要么全部执行，要么全部不执行。事务是数据库的逻辑工作单位，而且是必须是原子工作单位。","text":"事务 事务的概念 事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位 事务的特性：ACID 1) 原子性（atomicity）：对于其数据修改，要么全部执行，要么全部不执行。事务是数据库的逻辑工作单位，而且是必须是原子工作单位。 2) 一致性（consistency）：在事务执行前后，数据状态保持一致性。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。（实例：转账，两个账户余额相加，值不变。） 3) 隔离性（isolation）：一个事务的执行不能被其他事务所影响。 4) 持久性（durability）：一个事务一旦提交，事物的操作便永久性的保存在DB中。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 并发事务带来的问题 脏读（Dirty Read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to Modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 不可重复读（Unrepeatable Read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom Read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复度和幻读区别： ​ 不可重复读的重点是修改，幻读的重点在于新增或者删除。 ​ 例1：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 ​ 例2：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 事务隔离级别 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 。 (Oracle默认的事务隔离级别) REPEATABLE-READ（可重读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 (MySQL默认的事务隔离级别) SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"MySQL Summary","slug":"MySQL-Summary","date":"2020-05-15T16:35:41.000Z","updated":"2020-06-19T12:58:42.961Z","comments":true,"path":"2020/05/16/MySQL-Summary/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/16/MySQL-Summary/","excerpt":"MySQL 知识点总结 事务 并发问题 事务隔离级别 基本SQL语句 MySQL 架构 MySQL 存储引擎","text":"MySQL 知识点总结 事务 并发问题 事务隔离级别 基本SQL语句 MySQL 架构 MySQL 存储引擎 数据类型 索引 binlog redolog undolog MVCC sql 优化 MySQL 主从复制 执行计划 explain MySQL 慢查询 MySQL 占用CPU过高 分区分库分表 源码 https://dev.mysql.com/doc/refman/8.0/en/introduction.html","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"春招心得","slug":"春招心得","date":"2020-05-07T13:13:49.000Z","updated":"2020-06-19T13:53:05.076Z","comments":true,"path":"2020/05/07/春招心得/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/07/%E6%98%A5%E6%8B%9B%E5%BF%83%E5%BE%97/","excerpt":"突然就想记录一点东西在这里。 春招结束了，投了很多家公司，但是没有收到多少面试的邀请，所幸的是面试的基本都拿到的offer。 首先总结一下春招的情况吧。 收到面试邀请的公司有：腾讯，美团点评，蘑菇街，蚂蚁金服，微软，网易。 除了蘑菇街一面挂了，其他都拿到了offer。 对于这个结果我自己是挺满意的，但是过程却是那么的曲折。","text":"突然就想记录一点东西在这里。 春招结束了，投了很多家公司，但是没有收到多少面试的邀请，所幸的是面试的基本都拿到的offer。 首先总结一下春招的情况吧。 收到面试邀请的公司有：腾讯，美团点评，蘑菇街，蚂蚁金服，微软，网易。 除了蘑菇街一面挂了，其他都拿到了offer。 对于这个结果我自己是挺满意的，但是过程却是那么的曲折。 2月底我就开始海投，只要发了春招信息的互联网公司我都投了，但是迟迟没有收到面试的通知，投出去的简历石沉大海。直到有一天腾讯给我打来了第一通电话约我半小时后面试，那天很激动，也很仓促，不知所措。感谢腾讯爸爸的这通幸运的电话，后来就陆续收到了面试的通知。 然后总结一下面试的心得。 我觉得作为在校生，公司主要考察的部分还是我们的基础知识，思维能力，有项目的话会比较扣项目。 基础知识主要有：数据结构，算法，操作系统，数据库，计算机网络。 项目方面会考察：你做的项目的内容，你负责的部分，遇到的困难，解决困难的方法和思路以及态度，收获与成长。 说到这里，就很想感谢一下唱吧给了我实习的机会。在实习的期间，虽然我有偶尔会觉得做的事情有点枯燥和重复，但是我现在才发现，带给我最大益处的不是学到什么什么新技术，而是让我发现在工作中有哪些点应该去注意，考虑事情的时候应该更全面，从多方面。握着我们手上的不是简单的几行代码，而是成千上万的用户的体验。之前在学校做项目只是一股脑的实现功能就好，哪有想那么多。我好像扯远了…… 这次春招给我的感触很深。虽然春招是在找工作，但是也给了我很多工作方面的启迪。 首先，认真做记录是一件很好的事。记录你学到了什么，遇到了什么困难，如何解决。哪怕很小很小的一个点，它也值得被记录（不然面试的时候你真的想不起来自己遇到过什么问题），等你养成记录的良好的习惯之后，你就会发现你是有成长的，你遇到过那么多坎都勇敢的迈了过去，也要从中吸取经验，认真总结。以后遇到同样或者类似的问题，会更快的得到解决。 其次，基础知识很重要。很多人可能怕没有项目经验怎么办，我个人认为项目是对知识的实践，项目教会我们如何应用知识。但是，如果你基础知识不牢固，再多的项目也是被架空，是经不起考验的，最终还是得回到基础知识的学习上。那么我们现在既然没有办法有项目经验，就一定要让自己更有内容，有更扎实的功底。再花里胡哨的项目说到根本也是对各种知识的应用。所以，工作了之后也要坚持学习，除了学习新的技术，不扎实的地方也要好好补。 最后，要做一个会往后看也懂往前看的人。往后看，学会总结，总结你的知识，项目，选择，收获。往前看，有一个清晰的定位，规划，目标。它可以让我们更清楚的认清自己，更明白自己想要什么。有了目标，奋斗才会更加有动力。 希望每一份努力都不会被辜负！ 本来最开始我还在写面经，但是到后来就懒得写了，最核心的内容就是你懂得越多越好，越深越好（这话像在放pi) 感觉写了很多不怎么正确的点，但是这些想法只局限于此时此刻脑袋一热的想法，可能我明天就改变了… 怎么写了这么多了？ 我要去刷手机了。","categories":[],"tags":[{"name":"找工作","slug":"找工作","permalink":"https://jiayanfighting.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"}]},{"title":"Java 垃圾回收机制","slug":"Java-垃圾回收机制","date":"2019-07-14T10:01:36.000Z","updated":"2020-05-04T13:01:36.000Z","comments":true,"path":"2019/07/14/Java-垃圾回收机制/","link":"","permalink":"https://jiayanfighting.github.io/2019/07/14/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置","text":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置 一、内存分配 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆 JVM中共划分为三个代：新生代、年老代和持久代（新生代：老年代 = 1：2），持久代1.8之后被元空间取代 ​ 新生代：存放所有新生成的对象; ​ 年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象; 二、GC的类型 对新生代的对象的收集称为minor GC;（98% 的对象经过一次 Minor GC 后就会被回收） 对旧生代的对象的收集称为Full GC; 三、触发GC的条件 新生代没有足够空间时会触发Minor GC。 Java堆内存不足时，GC会被调用。 程序中主动调用System.gc()强制执行的GC（是Full GC）。 GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 四、如何GC 这部分详细介绍：垃圾判定的算法（引用计数法，可达性分析），垃圾回收算法（标记清理，复制，标记整理，分代回收，着重介绍分代回收算法），垃圾回收器 1. 垃圾的判定 对堆垃圾回收前的第一步就是要判断那些对象已经死亡 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 不可达的对象并非“非死不可”。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！ 注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记! GC Roots 到底是什么，哪些对象可以作为 GC Root ？有以下几类： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 JVM**对象的引用：**不同的对象引用类型，GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型: 1)强引用(Strong Reference):默认情况下，对象采用的均为强引用(这个对象的实例没有其他对象引用，GC时才会被回收)。平时声明变量使用的就是强引用，只要强引用还存在，垃圾收集器即使OOM也不会回收掉被引用的对象。 2)软引用(Soft Reference):软引用是Java中提供的种比较适合于缓存场景的应用(只有在内存不够用的情况下才会被GC)。描述有用但非必须的对象,在将要发生OOM之前会进行回收，如果回收还是没有足够内存才会抛OOM。 3)弱引用(Weak Reference):在GC时一定会被GC回收。描述非必须的对象，当垃圾收集器工作时，无论当前内存是否足够,都会回收掉只被弱引用关联的对象。 4)虚引用(Phantom Reference):由于虚引用只是用来得知对象是否被GC。最弱的一种引用关系，一个对象是否有虚引用的存在,完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 如何判断一个常量是废弃常量。运行时常量池主要回收的是废弃的常量。 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 注意：我们在 可能是把 Java 内存区域讲的最清楚的一篇文章 也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 如何判断一个类是无用的类 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 2.垃圾收集算法 1）标记-清除算法 该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。缺点： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 2）复制算法 它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 缺点：效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧），可用内存减半 3）标记-整理算法 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存 缺点：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下 4）分代收集算法 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 98% 的对象经过一次 Minor GC 后就会被回收，所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),Eden: S0: S1 = 8:1:1 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标**记-清除”或“标记-整理”算法**进行垃圾收集。 分代收集工作原理（过程）： 对象在新生代的分配和回收（复制算法） 对象一般分配在 Eden 区 当 Eden 区将满时，触发 Minor GC 经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，所以Eden 区远大于 S0,S1 ）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间 当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。 若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。 对象何时晋升到老年代 当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代 大对象。当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代 还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。 空间分配担保 在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。 Stop The World 如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。 什么是 STW ？在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。 Minor GC和Full GC触发条件 Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"Java JVM","slug":"Java-JVM","date":"2019-06-06T12:56:32.000Z","updated":"2020-03-04T13:01:36.000Z","comments":true,"path":"2019/06/06/Java-JVM/","link":"","permalink":"https://jiayanfighting.github.io/2019/06/06/Java-JVM/","excerpt":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解","text":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解 Java 虚拟机运行时数据区组成 具体介绍： 1. 虚拟机栈（JVM Stacks） 线程私有 每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 局部变量表：基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址））。当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定 的，在方法运行期间不会改变局部变量表的大小。 2. 本地方法栈（Native Method Stacks） 线程私有 本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。虚拟机栈为虚拟机执行Java方法（也就是字节码）服务 异常情况：与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常 3. 程序计数器（Program Counter Register） 线程私有 存放：每个线程下一步将执行的JVM指令, 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 记录当前线程的位置便于线程切换与恢复； 异常情况：程序计数器是唯一一个不会出现OutOfMemoryError （OOM）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 4. 堆（Heap） 线程共享 虚拟机启动时创建 存放：对象实例和数组 Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。Java虚拟机是可扩展的（通过参数-Xmx和-Xms设定）。 异常情况：如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。 5. 方法区（Method Area） 线程共享 存放：存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。 方法区只是一个概念，永久代或者元空间是它的实现 HotSpot虚拟机设计团队把收集器的分代设计扩展至方法区(使用永久代来实现方法区)，但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。 在JDK6的时候HotSpot逐步改为采用本地内存（Native Memory）来实现方法区，到JDK7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。 6. 运行时常量池（Runtime Constant Pool） 是方法区的一部分 存放：Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行期间也可以将新的常量放入池中。 异常情况：既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 7. 直接内存 不属于虚拟机运行时数据区 异常情况：动态扩展时会出现 OutOfMemoryError异常 元空间(MetaSpace) 存放：类的元数据。如方法、字段、类、包的描述信息，这些信息可以用于创建文档、跟踪代码中的依赖性、执行编译时检查 方法区里面的那些东西，大部分都被移到堆里面去了，还剩下一些元数据被保存在元空间里面 元空间有单独的元空间虚拟机执行内存分配与垃圾回收 为什么用元空间替换永久代？ 内存溢出的几率变小：永久代有固定大小上限。元空间的大小是受本机可用内存的限制，内存溢出的概率会更小。 提升GC性能：永久代的 GC 特别难搞，严重影响 Full GC 的性能。于是抛弃永久代，使用元空间，从而让 Full GC 不再关心方法区 增加可操作空间：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。 参考文献： 周志明. 深入理解Java虚拟机:JVM高级特性与最佳实践. 机械工业出版社, 2019.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"Hello","slug":"hello-world","date":"2019-01-06T09:56:32.000Z","updated":"2020-06-19T13:12:59.181Z","comments":true,"path":"2019/01/06/hello-world/","link":"","permalink":"https://jiayanfighting.github.io/2019/01/06/hello-world/","excerpt":"","text":"这是我的第一个自己搭建的博客网站，希望可以在这记录我学习和成长的过程，记录我学习的一些心得和笔记。分享给大家（应该没人知道） 之前一直都是在OneNote上记录，现在想自己整理整理一下以前的笔记，查漏补错，写在自己的博客上 ，或许这样更有仪式感吧hhhh。","categories":[],"tags":[{"name":"record","slug":"record","permalink":"https://jiayanfighting.github.io/tags/record/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://jiayanfighting.github.io/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://jiayanfighting.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"Map","slug":"Map","permalink":"https://jiayanfighting.github.io/tags/Map/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://jiayanfighting.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"},{"name":"web","slug":"web","permalink":"https://jiayanfighting.github.io/tags/web/"},{"name":"数据库","slug":"数据库","permalink":"https://jiayanfighting.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"leetcode","slug":"leetcode","permalink":"https://jiayanfighting.github.io/tags/leetcode/"},{"name":"找工作","slug":"找工作","permalink":"https://jiayanfighting.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"},{"name":"record","slug":"record","permalink":"https://jiayanfighting.github.io/tags/record/"}]}