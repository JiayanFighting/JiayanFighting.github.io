{"meta":{"title":"Jiayan's Blog","subtitle":"","description":"欢迎来到家晏的博客","author":"Jiayan Huang","url":"https://jiayanfighting.github.io","root":"/"},"pages":[{"title":"about","date":"2020-02-02T12:02:20.000Z","updated":"2020-05-06T16:52:16.759Z","comments":true,"path":"about/index.html","permalink":"https://jiayanfighting.github.io/about/index.html","excerpt":"","text":"个人简介 基本信息 姓名：黄家晏 年龄：23岁 Email： JiayanFighting@qq.com 教育背景 2019.9-2021.6 哈尔滨工业大学 计算机科学与技术 硕士 实验室：海量数据计算研究中心 研究方向：边缘计算，移动边缘计算系统中的任务调度算法和边缘云的定价博弈 2015.9-2019.6 哈尔滨工业大学 软件工程 学士 专业排名：4/101 CET-6 主修课程：数据结构，算法分析与设计，操作系统，计算机网络，数据库系统，Java，Java EE 等。 专业技能 熟悉Java语法，具有Java编程相关经验 对JVM，垃圾回收机制，内存模型等有一定了解 对数据结构、算法有一定了解 了解常用Java开源框架， Spring、SpringMVC、MyBatis等 熟悉MySQL，Redis等主流数据库，熟悉事务、索引等数据库相关技术 熟悉HTTP，TCP，IP等网络协议 了解PHP语言，有一定的PHP编程相关经验 掌握Git，SVN，Charles，Matlab等常用工具 实习经历 2018.8-2019.5 北京小唱科技有限公司 后端开发实习生 责任描述： 唱吧App的功能开发，包括版本功能开发，活动开发等。 礼物系统重构。从后端系统中解耦出礼物相关功能，兼容原接口，重新构建礼物系统，并引入定制化礼物箱功 能，实现礼物后台接口。 活动数据的统计，线上bug的修复等。 涉及技术：PHP，Nginx，数据库相关技术，包括MySQL，Redis，Memcached等。 2017.7-2017.8 东软 开发实习生 功能描述：管理公司的人员出勤情况；员工职位变化，部门更改等信息管理；员工请假，逐级审批，假期计算等 功能。 责任描述： 数据库的设计；系统功能模块的划分；部门信息管理和请假管理的代码的书写；组员工作的分配；代 码的整合。 涉及技术：Spring，SpringMVC，Mybatis，MySQL等。 项目经验 2018.11-2019.3 评论过滤系统 功能描述：用户进行评论操作时，进行评论的分类，筛选中言语不当的评论，阻止该评论的发表。 系统设计：分为四个模块，首先对文本和用户属性数据的提取，然后将提取的数据进行预处理，再用朴素贝叶斯 算法训练分类模型，最后利用互信息和左右信息熵在负面评论中挖掘新的骂人词汇，辅助分类模型进行强分类， 优化分类效果。 涉及技术：机器学习，MySQL，Redis，Python等。 2017.12-2018.3 渠道交易平台 功能描述：渠道商，销售人员，渠道商管理人员，商户，系统管理人员的信息管理；订单管理，提成计算等；权 限管理。 责任描述：不同级别的渠道商服务商和代理商的信息处理；销售人员的信息管理；各级渠道商和销售人员的交易 统计，提成计算；文件的导入与导出。 涉及技术：SpringBoot，Mybatis，MySQL，Thymeleaf，Shiro等。 2017.11-2017.12 编译器 功能描述： • 词法分析。根据输入的代码，自动识别出单词关键字数字等，列出token 序列。能识别各种单词拼写错误。 • 语法分析。能识别声明语句，赋值语句，分支语句，循环语句等，构造语法分析树，并具备语法错误处理能力。 • 语义分析。识别常用语句类型，并生成中间代码，列出符号表，三地址指令和四元式序列等，并具备语义错误处 理能力，能准确给出错误所在位置，并采用可行的错误恢复策略。 研究方向 Paper：《Approximated Assignment Algorithms for Unordered and Ordered Tasks in Data Shared MEC Systems 》 Journal: Transactions on Mobile Computing Status：Under Review 本文详细研究了数据共享移动边缘计算系统中的任务分配算法。针对MEC系统中常见的有序任务，给出了一种启 发式算法。从理论上分析了该问题的难易程度、算法的正确性、复杂度。最后，进行了大量的实验研究。理论分 析和实验结果均表明，所提出的算法在时延、满足率和能量消耗方面都具有较高的性能。 荣誉奖项 一等优秀推免奖学金，长园奖学金 多次获得一等人民奖学金，励志奖学金 蓝桥杯Java软件开发大学A组二等奖 基于Unity3D冒险类游戏开发二等奖 个人评价 乐观开朗，适应能力强，能接受加班和出差 热爱写代码，有良好的编程习惯 具有良好的沟通能力，能快速融入团队 有责任心，学习能力强 谢谢观看！"},{"title":"categories","date":"2020-05-06T14:46:57.000Z","updated":"2020-05-06T14:46:57.889Z","comments":true,"path":"categories/index.html","permalink":"https://jiayanfighting.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-06T14:47:10.000Z","updated":"2020-05-06T14:47:10.032Z","comments":true,"path":"tags/index.html","permalink":"https://jiayanfighting.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot项目部署到服务器","slug":"SpringBoot项目部署到服务器","date":"2020-05-31T14:40:22.000Z","updated":"2020-05-31T14:55:37.985Z","comments":true,"path":"2020/05/31/SpringBoot项目部署到服务器/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/31/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"有两种方法，jar 和war. 主要讲一下用jar 部署","text":"有两种方法，jar 和war. 主要讲一下用jar 部署 添加maven 依赖 Idea 图形化打包 项目生成在target目录下 jar包传到服务器上 然后执行 12java -jar cloudschool-0.0.1-SNAPSHOT.jar&#x2F;&#x2F; java -jar 生成的jar的名称","categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"}]},{"title":"SpringBoot搭建web项目","slug":"SpringBoot搭建web项目","date":"2020-05-31T12:16:50.000Z","updated":"2020-05-31T14:12:34.518Z","comments":true,"path":"2020/05/31/SpringBoot搭建web项目/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/31/SpringBoot%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/","excerpt":"这篇文章主要介绍一下使用SpringBoot从零搭建web项目，demo主要演示登录的功能","text":"这篇文章主要介绍一下使用SpringBoot从零搭建web项目，demo主要演示登录的功能 在 https://start.spring.io/ 上生成初始化文件 会生成.zip文件，将文件解压 在IDEA中打开这个项目 ​ 这里有一个问题就是：Idea打开项目后 maven下载依赖会卡在 Resolving Maven dependencies ​ 解决：①把镜像地址换成阿里的，具体操作：更改maven 配置文件，在IDEA安装目录下IDEA\\plugins\\maven\\lib\\maven3\\conf\\setting.xml 中添加配置信息 ​ ② 修改参数设置：https://cloud.tencent.com/developer/article/1461546 运行 直接运行 src/main/java/com/google/cloudschool/CloudschoolApplication.java就可以 在浏览器输入localhost:8080就可以访问了. 简单的demo见 https://spring.io/quickstart 步入正题：访问登录界面 方法一：ip:端口/静态资源 把静态资源放到resources/static下,这是springboot静态资源默认访问路径。 在浏览器直接ip:端口/静态资源 就可以了，如： 方法二：用localhost:8080/login 编写login.html 放在resource/templates目录下。 新建LoginController 首先新建一个controller文件夹，在controller目录下新建LoginController.java。 代码： 123456789101112package com.google.cloudschool.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class LoginController &#123; @RequestMapping(\"/login\") public String welcomeLogin()&#123; return \"login\"; &#125;&#125; 在pom.xml文件中加入依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 访问localhost:8080/login 进行登录操作：后端方面 因为要用到MyBatis，所以我们首先配置MyBatis 配置MyBatis依赖 修改pom.xml文件，加入： 123456789&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; resource 目录下新建application.yml文件 进行数据源设置，写入： 123456789spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://139.196.9.111:3306/springboot?useUnicode=true&amp;characterEncoding=utf8 username: root password: 12345678mybatis: type-aliases-package: com.example.demo.dao mapper-locations: classpath:mapper/*Mapper.xml MyBatis 配置完成。 新建controller，service，dao，domain文件夹 如图： 编写login.html，Jquery Ajax发送post请求 编写controller，service, serviceImpl，mapper 文件结构 LoginController.java处理post请求方法 123456789101112131415@PostMapping(\"/login\")@ResponseBodyString ajaxLogin(String username, String password) &#123; System.out.println(\"username=\"+username+\" password=\"+password); int code = userService.login(username,password); System.out.println(\"code = \"+code); JSONObject result = new JSONObject() ; result.put(\"code\",code); if (code &gt;= 1) &#123; result.put(\"msg\",\"登录成功！\"); &#125;else &#123; result.put(\"msg\",\"用户或密码错误！\"); &#125; return result.toJSONString();&#125; UserService.java 12345package com.google.cloudschool.service;public interface UserService &#123; int login(String username, String password);&#125; UserServiceImpl.java 123456789101112131415161718package com.google.cloudschool.service.Impl;import com.google.cloudschool.dao.UserMapper;import com.google.cloudschool.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired UserMapper userMapper; @Override public int login(String username, String password) &#123; return userMapper.login(username,password); &#125;&#125; UserMapper.java 12345678910package com.google.cloudschool.dao;import org.apache.ibatis.annotations.*;@Mapperpublic interface UserMapper &#123; @Select(\"select count(*) from user where username = #&#123;param1&#125; and password = #&#123;param2&#125; \") int login(String username, String password);&#125; login.html 发送post登录请求就可以去数据库查询到是否有该用户啦 登录成功就跳转新界面啦！ 测试接口调用 用chrome浏览器的Talend API Tester扩展程序模拟发送请求（只调用接口的话可以注释掉thymeleaf的）","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"},{"name":"web","slug":"web","permalink":"https://jiayanfighting.github.io/tags/web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"}]},{"title":"索引","slug":"索引","date":"2020-05-25T09:57:59.000Z","updated":"2020-05-25T10:00:39.487Z","comments":true,"path":"2020/05/25/索引/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/25/%E7%B4%A2%E5%BC%95/","excerpt":"MySQL中索引的优点和缺点和使用原则","text":"MySQL中索引的优点和缺点和使用原则 优点： ​ 1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引 ​ 2、大大加快数据的查询速度 缺点： 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加 2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。 使用原则： 1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引 2、数据量小的表最好不要使用索引。因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。 3、在一同值少的列上(字段上)不要建立索引，相反的，在一个字段上不同值较多可以建立索引。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://jiayanfighting.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL 优化","slug":"SQL-优化","date":"2020-05-24T15:48:18.000Z","updated":"2020-05-25T13:50:40.871Z","comments":true,"path":"2020/05/24/SQL-优化/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/24/SQL-%E4%BC%98%E5%8C%96/","excerpt":"一个好的sql语句能很好的提高sql速度 建立索引：首先考虑在 where group by及 order by 涉及的列 一定不要使用 select * 进行查询，因为会返回过多无用的字段会降低查询效率。应该使用具体的字段代替*，只返回使用到的字段。","text":"一个好的sql语句能很好的提高sql速度 建立索引：首先考虑在 where group by及 order by 涉及的列 一定不要使用 select * 进行查询，因为会返回过多无用的字段会降低查询效率。应该使用具体的字段代替*，只返回使用到的字段。 尽量不要在 where 子句中对字段进行 表达式操作 ，这样也会造成全表扫描。如： 1select id FROM t_order where num/2=100 ​ 应改为: 1select id FROM t_order where num=100*2 where条件里尽量不要进行null 值的判断，null的判断也会造成全表扫描。如： 1select * from t_order where score is NULL ​ 优化： ​ 给字段添加默认值，对默认值进行判断。如： 1select * from t_order where score = 0 应尽量避免在 where 子句中使用!=或&lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 尽量不要在where条件中等号的左侧进行表达式/函数操作 ，会导致全表扫描。如下： 12select * from t_order2 where score/10 = 10;select * from t_order2 where SUBSTR(customer,1,5) = 'zhang'; ​ 优化： ​ 将表达式.函数操作移动到等号右侧。如下： 12SELECT * FROM t_order2 WHERE score = 10*10;SELECT * FROM t_order2 WHERE customer LIKE 'zhang%'; 不要在where条件中使用左右两边都是%的like模糊查询 ，如： 1SELECT * FROM t_order WHERE customer LIKE '%zhang%' ​ 这样会导致数据库引擎放弃索引进行全表扫描。 ​ 优化：尽量在字段后面使用模糊查询。如下： 1SELECT * FROM t_order WHERE customer LIKE 'zhang%' 尽量不要使用where 1=1 的条件 ​ 有时候，在开发过程中，为了方便拼装查询条件，我们会加上该条件，这样，会造成进行全表扫描。如下： 1SELECT * FROM t_order WHERE 1=1 ​ 优化： ​ 如果用代码拼装sql，则由代码进行判断，没where加where，有where加and ​ 如果用mybatis，请用mybatis的where语法。 尽量不要使用in 和not in ，会造成全表扫描。如下： 12SELECT * FROM t_order WHERE id IN (2,3)SELECT * FROM t_order1 WHERE customer IN (SELECT customer FROM t_order2) ​ 优化： ​ 对于连续的数值，能用 between 就不要用 in ，如下：SELECT * FROM t_order WHERE id BETWEEN 2 AND 3 ​ 对于子查询，可以用exists代替。如下： 1SELECT * FROM t_order1 WHERE EXISTS (SELECT * FROM t_order2 WHERE t1.customer = t2.customer) 尽量不要使用or ，会造成全表扫描。如下： 1SELECT * FROM t_order WHERE id = 1 OR id = 3 ​ 优化：可以用union代替or。如下： 123SELECT * FROM t_order WHERE id = 1UNIONSELECT * FROM t_order WHERE id = 3 很多时候用 exists 代替 in 是一个好的选择： 1select num from a where num in(select num from b) ​ 用下面的语句替换： 1select num from a where exists(select 1 from b where num=a.num) 程序要尽量避免大事务操作，提高系统并发能力。 一个表的索引数最好不要超过6个，如果索引太多的话，就需要考虑一下那些不常使用到的列上建的索引是否有必要。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率， 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： ​ select col1,col2 into #t from t where 1=0 ​ 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： ​ create table #t(…) 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间。其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"Leetcode","slug":"Leetcode","date":"2020-05-17T15:59:29.000Z","updated":"2020-05-25T09:29:33.655Z","comments":true,"path":"2020/05/17/Leetcode/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/17/Leetcode/","excerpt":"这是我刷题的一些记录，主要分为如下几类： 二分 回溯/递归 动态规划","text":"这是我刷题的一些记录，主要分为如下几类： 二分 回溯/递归 动态规划 双指针 &amp; 滑动窗口 三指针 链表 二叉树 栈 位运算 哈希 其他 二分查找 Title Des Tag Thought Complexity Code 33. 搜索旋转排序数组 搜索一个给定的目标值，数组中是否存在这个目标值， 假设数组中不存在重复元素。 二分查找 确定升序的区间 O(logN) 34. 在排序数组中查找元素的第一个和最后一个位置 升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置 二分查找 找两次，找左右边界 35. 搜索插入位置 69. x 的平方根 计算并返回 x 的平方根 二分查找 对于很大的数，乘法变除法 74. 搜索二维矩阵 二分 or 从右上角开始 81. 搜索旋转排序数组 II 搜索一个给定的目标值，数组中是否存在这个目标值， 假设数组中存在重复元素。 二分查找 O(logN) 153. 寻找旋转排序数组中的最小值 找出其中最小的元素。 假设数组中不存在重复元素。 二分 O(logN) 154. 寻找旋转排序数组中的最小值 II 找出其中最小的元素 数组中存在重复元素 二分 O(logN) 162. 寻找峰值 峰值元素是指其值大于左右相邻值的元素 二分&amp;递归 O(logN) while(l&lt;r){ int mid=(l+r)/2; if(nums[mid]&gt;nums[mid+1]) r=mid; else l=mid+1; }","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://jiayanfighting.github.io/tags/leetcode/"}]},{"title":"Transaction","slug":"Transaction","date":"2020-05-15T16:44:59.000Z","updated":"2020-05-17T15:34:30.999Z","comments":true,"path":"2020/05/16/Transaction/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/16/Transaction/","excerpt":"事务 事务的概念 事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位 事务的特性：ACID 1) 原子性（atomicity）：对于其数据修改，要么全部执行，要么全部不执行。事务是数据库的逻辑工作单位，而且是必须是原子工作单位。","text":"事务 事务的概念 事务是用户定义的一个数据库的操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位 事务的特性：ACID 1) 原子性（atomicity）：对于其数据修改，要么全部执行，要么全部不执行。事务是数据库的逻辑工作单位，而且是必须是原子工作单位。 2) 一致性（consistency）：在事务执行前后，数据状态保持一致性。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。（实例：转账，两个账户余额相加，值不变。） 3) 隔离性（isolation）：一个事务的执行不能被其他事务所影响。 4) 持久性（durability）：一个事务一旦提交，事物的操作便永久性的保存在DB中。即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 并发事务带来的问题 脏读（Dirty Read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。 丢失修改（Lost to Modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 不可重复读（Unrepeatable Read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 幻读（Phantom Read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。 不可重复度和幻读区别： ​ 不可重复读的重点是修改，幻读的重点在于新增或者删除。 ​ 例1：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。 ​ 例2：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。 事务隔离级别 READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 READ-COMMITTED(读取已提交): 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 。 (Oracle默认的事务隔离级别) REPEATABLE-READ（可重读）: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 (MySQL默认的事务隔离级别) SERIALIZABLE(可串行化): 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"MySQL Summary","slug":"MySQL-Summary","date":"2020-05-15T16:35:41.000Z","updated":"2020-05-15T16:37:59.960Z","comments":true,"path":"2020/05/16/MySQL-Summary/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/16/MySQL-Summary/","excerpt":"MySQL 知识点总结 事务 并发问题 事务隔离级别 基本SQL语句 索引","text":"MySQL 知识点总结 事务 并发问题 事务隔离级别 基本SQL语句 索引 binlog redolog undolog mvcc sql 优化 MySQL 主从复制 执行计划 explain MySQL 慢查询 MySQL 占用CPU过高 InnoDB vs MyISAM","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"}]},{"title":"Java 垃圾回收机制","slug":"Java-垃圾回收机制","date":"2020-05-03T10:01:36.000Z","updated":"2020-05-04T13:01:36.000Z","comments":true,"path":"2020/05/03/Java-垃圾回收机制/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/03/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置","text":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置 一、内存分配 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆 JVM中共划分为三个代：新生代、年老代和持久代（新生代：老年代 = 1：2），持久代1.8之后被元空间取代 ​ 新生代：存放所有新生成的对象; ​ 年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象; 二、GC的类型 对新生代的对象的收集称为minor GC;（98% 的对象经过一次 Minor GC 后就会被回收） 对旧生代的对象的收集称为Full GC; 三、触发GC的条件 新生代没有足够空间时会触发Minor GC。 Java堆内存不足时，GC会被调用。 程序中主动调用System.gc()强制执行的GC（是Full GC）。 GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 四、如何GC 这部分详细介绍：垃圾判定的算法（引用计数法，可达性分析），垃圾回收算法（标记清理，复制，标记整理，分代回收，着重介绍分代回收算法），垃圾回收器 1. 垃圾的判定 对堆垃圾回收前的第一步就是要判断那些对象已经死亡 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 不可达的对象并非“非死不可”。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！ 注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记! GC Roots 到底是什么，哪些对象可以作为 GC Root ？有以下几类： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 JVM**对象的引用：**不同的对象引用类型，GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型: 1)强引用(Strong Reference):默认情况下，对象采用的均为强引用(这个对象的实例没有其他对象引用，GC时才会被回收)。平时声明变量使用的就是强引用，只要强引用还存在，垃圾收集器即使OOM也不会回收掉被引用的对象。 2)软引用(Soft Reference):软引用是Java中提供的种比较适合于缓存场景的应用(只有在内存不够用的情况下才会被GC)。描述有用但非必须的对象,在将要发生OOM之前会进行回收，如果回收还是没有足够内存才会抛OOM。 3)弱引用(Weak Reference):在GC时一定会被GC回收。描述非必须的对象，当垃圾收集器工作时，无论当前内存是否足够,都会回收掉只被弱引用关联的对象。 4)虚引用(Phantom Reference):由于虚引用只是用来得知对象是否被GC。最弱的一种引用关系，一个对象是否有虚引用的存在,完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 如何判断一个常量是废弃常量。运行时常量池主要回收的是废弃的常量。 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 注意：我们在 可能是把 Java 内存区域讲的最清楚的一篇文章 也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 如何判断一个类是无用的类 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 2.垃圾收集算法 1）标记-清除算法 该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。缺点： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 2）复制算法 它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 缺点：效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧），可用内存减半 3）标记-整理算法 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存 缺点：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下 4）分代收集算法 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 98% 的对象经过一次 Minor GC 后就会被回收，所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),Eden: S0: S1 = 8:1:1 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标**记-清除”或“标记-整理”算法**进行垃圾收集。 分代收集工作原理（过程）： 对象在新生代的分配和回收（复制算法） 对象一般分配在 Eden 区 当 Eden 区将满时，触发 Minor GC 经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，所以Eden 区远大于 S0,S1 ）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间 当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。 若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。 对象何时晋升到老年代 当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代 大对象。当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代 还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。 空间分配担保 在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。 Stop The World 如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。 什么是 STW ？在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。 Minor GC和Full GC触发条件 Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"Java JVM","slug":"Java-JVM","date":"2019-05-06T09:56:32.000Z","updated":"2020-05-06T10:08:39.861Z","comments":true,"path":"2019/05/06/Java-JVM/","link":"","permalink":"https://jiayanfighting.github.io/2019/05/06/Java-JVM/","excerpt":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解","text":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解 JVM内存区域组成： $\\leq$1.6 ： 程序计数器，虚拟机栈，本地方法栈，堆，方法区（其中包含运行时常量池，字符串常量池） 1.7 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），方法区 $\\geq$1.8 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），元空间 变化： 1.6 vs 1.7：运行时常量池，字符串常量池从方法区移到堆，并且，加载的类信息…等被转移到 堆 里面的运行时常量池中了 1.7 vs 1.8 ：方法区从运行时数据区移到直接内存，元空间替代永久代 JDK 1.6 具体介绍： 虚拟机栈 (JVM Stacks) 线程私有 存放：是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表（八种基本数据类型变量，部分的返回结果，非基本类型对象指向堆上的地址）、操作数栈、动态链接、方法出口信息。 不需要进行 GC。 本地方法栈(Native Method Stacks) 线程私有 存放：每个native方法调用的状态 为虚拟机执行本地方法时服务的 不需要进行 GC 程序计数器 线程私有 存放：每个线程下一步将执行的JVM指令, 如该方法为native的，则PC寄存器中不存储任何信息。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 记录当前线程的位置便于线程切换与恢复； 程序计数器是唯一一个不会出现 OutOfMemoryError （OOM）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 堆 (Heap) 线程共享 存放：对象实例和数组 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆。从垃圾回收的角度， Java 堆还可以细分为：新生代和老年代。 1.7 的方法区 (Method Area) 线程共享 存放：被虚拟机加载的类信息(名称、修饰符等)、类中的静态变量、 类中定义为final类型的常量、类中的Field信息、类中的方法信息 方法区只是一个概念，永久代或者元空间是它的实现 运行时常量池(Runtime Constant Pool) 存放：类中的固定的常量信息、方法和Field的引用信息等。编译期间生成的字面量、符号引用 元空间 (MetaSpace) 在直接内存中 存放：类的元数据。如方法、字段、类、包的描述信息，这些信息可以用于创建文档、跟踪代码中的依赖性、执行编译时检查 方法区里面的那些东西，大部分都被移到堆里面去了，还剩下一些元数据被保存在元空间里面 元空间有单独的元空间虚拟机执行内存分配与垃圾回收 为什么用元空间替换永久代？ 内存溢出的几率变小：永久代有固定大小上限。元空间的大小是受本机可用内存的限制，内存溢出的概率会更小。 提升GC性能：永久代的 GC 特别难搞，严重影响 Full GC 的性能。于是抛弃永久代，使用元空间，从而让 Full GC 不再关心方法区 增加可操作空间：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T09:56:32.000Z","updated":"2020-05-06T10:09:07.478Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"https://jiayanfighting.github.io/2018/05/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]}],"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://jiayanfighting.github.io/tags/SpringBoot/"},{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"},{"name":"web","slug":"web","permalink":"https://jiayanfighting.github.io/tags/web/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jiayanfighting.github.io/tags/MySQL/"},{"name":"数据库","slug":"数据库","permalink":"https://jiayanfighting.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"leetcode","slug":"leetcode","permalink":"https://jiayanfighting.github.io/tags/leetcode/"},{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]}