{"meta":{"title":"Jiayan's Blog","subtitle":"","description":"欢迎来到家晏的博客","author":"Jiayan Huang","url":"https://jiayanfighting.github.io","root":"/"},"pages":[],"posts":[{"title":"Java 垃圾回收机制","slug":"Java-垃圾回收机制","date":"2020-05-03T10:01:36.000Z","updated":"2020-05-04T13:01:36.000Z","comments":true,"path":"2020/05/03/Java-垃圾回收机制/","link":"","permalink":"https://jiayanfighting.github.io/2020/05/03/Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","excerpt":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置","text":"垃圾回收机制 Java 垃圾回收机制是Java很重要的一部分内容，本文会对Java垃圾回收的以下内容进行介绍： 内存是如何分配的 GC的类型 触发GC的条件（什么时候会GC） 如何GC 判定垃圾 GC算法（分代回收的具体过程） 垃圾收集器 GC中常用参数配置 一、内存分配 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆 JVM中共划分为三个代：新生代、年老代和持久代（新生代：老年代 = 1：2），持久代1.8之后被元空间取代 ​ 新生代：存放所有新生成的对象; ​ 年老代：在年轻代中经历了N次垃圾回收仍然存活的对象，将被放到年老代中，故都是一些生命周期较长的对象; 二、GC的类型 对新生代的对象的收集称为minor GC;（98% 的对象经过一次 Minor GC 后就会被回收） 对旧生代的对象的收集称为Full GC; 三、触发GC的条件 新生代没有足够空间时会触发Minor GC。 Java堆内存不足时，GC会被调用。 程序中主动调用System.gc()强制执行的GC（是Full GC）。 GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用。 四、如何GC 这部分详细介绍：垃圾判定的算法（引用计数法，可达性分析），垃圾回收算法（标记清理，复制，标记整理，分代回收，着重介绍分代回收算法），垃圾回收器 1. 垃圾的判定 对堆垃圾回收前的第一步就是要判断那些对象已经死亡 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析 这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 不可达的对象并非“非死不可”。对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！ 注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记! GC Roots 到底是什么，哪些对象可以作为 GC Root ？有以下几类： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 JVM**对象的引用：**不同的对象引用类型，GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型: 1)强引用(Strong Reference):默认情况下，对象采用的均为强引用(这个对象的实例没有其他对象引用，GC时才会被回收)。平时声明变量使用的就是强引用，只要强引用还存在，垃圾收集器即使OOM也不会回收掉被引用的对象。 2)软引用(Soft Reference):软引用是Java中提供的种比较适合于缓存场景的应用(只有在内存不够用的情况下才会被GC)。描述有用但非必须的对象,在将要发生OOM之前会进行回收，如果回收还是没有足够内存才会抛OOM。 3)弱引用(Weak Reference):在GC时一定会被GC回收。描述非必须的对象，当垃圾收集器工作时，无论当前内存是否足够,都会回收掉只被弱引用关联的对象。 4)虚引用(Phantom Reference):由于虚引用只是用来得知对象是否被GC。最弱的一种引用关系，一个对象是否有虚引用的存在,完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。 如何判断一个常量是废弃常量。运行时常量池主要回收的是废弃的常量。 假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 注意：我们在 可能是把 Java 内存区域讲的最清楚的一篇文章 也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 如何判断一个类是无用的类 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 2.垃圾收集算法 1）标记-清除算法 该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。缺点： 效率问题 空间问题（标记清除后会产生大量不连续的碎片） 2）复制算法 它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。 缺点：效率低下（我们可以想想删除数组元素再把非删除的元素往一端移，效率显然堪忧），可用内存减半 3）标记-整理算法 根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存 缺点：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下 4）分代收集算法 当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。 98% 的对象经过一次 Minor GC 后就会被回收，所以分代收集算法根据对象存活周期的不同将堆分成新生代和老生代（Java8以前还有个永久代）,默认比例为 1 : 2，新生代又分为 Eden 区， from Survivor 区（简称S0），to Survivor 区(简称 S1),Eden: S0: S1 = 8:1:1 比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标**记-清除”或“标记-整理”算法**进行垃圾收集。 分代收集工作原理（过程）： 对象在新生代的分配和回收（复制算法） 对象一般分配在 Eden 区 当 Eden 区将满时，触发 Minor GC 经过 Minor GC 后只有少部分对象会存活，它们会被移到 S0 区（Minor GC 把大部对象（接近98%）都回收了,只留下少量存活的对象，所以Eden 区远大于 S0,S1 ）同时对象年龄加一（对象的年龄即发生 Minor GC 的次数），最后把 Eden 区对象全部清理以释放出空间 当触发下一次 Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。 若再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。 对象何时晋升到老年代 当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代 大对象。当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代，因为如果把大对象分配在 Eden 区, Minor GC 后再移动到 S0,S1 会有很大的开销（对象比较大，复制会比较慢，也占空间），也很快会占满 S0,S1 区，所以干脆就直接移到老年代 还有一种情况也会让对象晋升到老年代，即在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。 空间分配担保 在发生 MinorGC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，那么Minor GC 可以确保是安全的,如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行 Minor GC，否则可能进行一次 Full GC。 Stop The World 如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。 什么是 STW ？在 GC（minor GC 或 Full GC）期间，只有垃圾回收器线程在工作，其他工作线程则被挂起。 Minor GC和Full GC触发条件 Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： 调用System.gc时，系统建议执行Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小大于老年代的可用内存 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"}]},{"title":"Java JVM","slug":"Java-JVM","date":"2019-05-06T09:56:32.000Z","updated":"2020-05-06T10:08:39.861Z","comments":true,"path":"2019/05/06/Java-JVM/","link":"","permalink":"https://jiayanfighting.github.io/2019/05/06/Java-JVM/","excerpt":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解","text":"Java JVM 1. 运行时数据区 Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。 主要知识点： 运行时数据区的组成（JDK 1.6，JDK 1.7，JDK 1.8的区别） 每个区域的详解 JVM内存区域组成： $\\leq$1.6 ： 程序计数器，虚拟机栈，本地方法栈，堆，方法区（其中包含运行时常量池，字符串常量池） 1.7 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），方法区 $\\geq$1.8 ： 程序计数器，虚拟机栈，本地方法栈，堆（其中包含运行时常量池，字符串常量池），元空间 变化： 1.6 vs 1.7：运行时常量池，字符串常量池从方法区移到堆，并且，加载的类信息…等被转移到 堆 里面的运行时常量池中了 1.7 vs 1.8 ：方法区从运行时数据区移到直接内存，元空间替代永久代 JDK 1.6 具体介绍： 虚拟机栈 (JVM Stacks) 线程私有 存放：是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表（八种基本数据类型变量，部分的返回结果，非基本类型对象指向堆上的地址）、操作数栈、动态链接、方法出口信息。 不需要进行 GC。 本地方法栈(Native Method Stacks) 线程私有 存放：每个native方法调用的状态 为虚拟机执行本地方法时服务的 不需要进行 GC 程序计数器 线程私有 存放：每个线程下一步将执行的JVM指令, 如该方法为native的，则PC寄存器中不存储任何信息。 字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 记录当前线程的位置便于线程切换与恢复； 程序计数器是唯一一个不会出现 OutOfMemoryError （OOM）的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 堆 (Heap) 线程共享 存放：对象实例和数组 Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆。从垃圾回收的角度， Java 堆还可以细分为：新生代和老年代。 1.7 的方法区 (Method Area) 线程共享 存放：被虚拟机加载的类信息(名称、修饰符等)、类中的静态变量、 类中定义为final类型的常量、类中的Field信息、类中的方法信息 方法区只是一个概念，永久代或者元空间是它的实现 运行时常量池(Runtime Constant Pool) 存放：类中的固定的常量信息、方法和Field的引用信息等。编译期间生成的字面量、符号引用 元空间 (MetaSpace) 在直接内存中 存放：类的元数据。如方法、字段、类、包的描述信息，这些信息可以用于创建文档、跟踪代码中的依赖性、执行编译时检查 方法区里面的那些东西，大部分都被移到堆里面去了，还剩下一些元数据被保存在元空间里面 元空间有单独的元空间虚拟机执行内存分配与垃圾回收 为什么用元空间替换永久代？ 内存溢出的几率变小：永久代有固定大小上限。元空间的大小是受本机可用内存的限制，内存溢出的概率会更小。 提升GC性能：永久代的 GC 特别难搞，严重影响 Full GC 的性能。于是抛弃永久代，使用元空间，从而让 Full GC 不再关心方法区 增加可操作空间：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-06T09:56:32.000Z","updated":"2020-05-06T10:09:07.478Z","comments":true,"path":"2018/05/06/hello-world/","link":"","permalink":"https://jiayanfighting.github.io/2018/05/06/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://jiayanfighting.github.io/tags/Java/"},{"name":"java","slug":"java","permalink":"https://jiayanfighting.github.io/tags/java/"}]}